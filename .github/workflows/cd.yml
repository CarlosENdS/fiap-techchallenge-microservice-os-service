name: CD Pipeline

on:
  push:
    branches: [main]
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

env:
  JAVA_VERSION: '21'
  AWS_REGION: us-east-1
  ECR_REPOSITORY: cargarage-app
  EKS_CLUSTER_NAME: cargarage-eks-prod
  TF_CLOUD_ORGANIZATION: fiap-soat-techchallenge
  TF_WORKSPACE: fiap-techchallenge-infra-database

jobs:
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    permissions:
      contents: read

    outputs:
      image-tag: ${{ steps.version.outputs.version }}
      image-uri: ${{ steps.ecr-login.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ steps.version.outputs.version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: maven

      - name: Extract version from POM
        id: version
        working-directory: ./app
        run: |
          VERSION=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Extracted version: ${VERSION}"

      - name: Build with Maven
        working-directory: ./app
        run: mvn clean package -DskipTests -B

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: ecr-login
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: ./app
          file: ./app/Dockerfile
          push: true
          tags: |
            ${{ steps.ecr-login.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ steps.version.outputs.version }}
            ${{ steps.ecr-login.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: build-and-push
    environment: ${{ github.event.inputs.environment || 'staging' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Fetch infrastructure outputs from Terraform Cloud
        id: tf-outputs
        uses: hashicorp/tfc-workflows-github/actions/workspace-output@v1.3.0
        with:
          hostname: app.terraform.io
          token: ${{ secrets.TF_API_TOKEN }}
          organization: ${{ env.TF_CLOUD_ORGANIZATION }}
          workspace: ${{ env.TF_WORKSPACE }}

      - name: Mask infrastructure outputs
        env:
          TF_OUTPUTS_JSON: ${{ steps.tf-outputs.outputs.workspace-outputs-json }}
        run: |
          # Mask the entire JSON output to prevent it from appearing in subsequent logs
          echo "::add-mask::${TF_OUTPUTS_JSON}"

          # Extract and mask individual sensitive values
          for value in $(echo "$TF_OUTPUTS_JSON" | jq -r '.outputs[].value // empty' 2>/dev/null); do
            if [[ -n "$value" && "$value" != "null" ]]; then
              echo "::add-mask::${value}"
            fi
          done

      - name: Parse Terraform outputs
        id: parsed-outputs
        env:
          TF_OUTPUTS_JSON: ${{ steps.tf-outputs.outputs.workspace-outputs-json }}
        run: |
          set -euo pipefail

          # Helper function to extract value from outputs array by name
          get_output() {
            local val
            val=$(echo "$TF_OUTPUTS_JSON" | jq -r --arg name "$1" '.outputs[] | select(.name == $name) | .value // empty')
            # Return empty if null
            if [[ "$val" == "null" ]]; then
              echo ""
            else
              echo "$val"
            fi
          }

          # Parse outputs from tfc-workflows action (array format)
          IRSA_ROLE_ARN=$(get_output "os_service_irsa_role_arn")
          SQS_OS_EVENTS=$(get_output "sqs_os_events_queue_url")
          SQS_QUOTE_APPROVED=$(get_output "sqs_quote_approved_queue_url")
          SQS_EXECUTION_COMPLETED=$(get_output "sqs_execution_completed_queue_url")
          SQS_PAYMENT_FAILED=$(get_output "sqs_payment_failed_queue_url")
          SQS_RESOURCE_UNAVAILABLE=$(get_output "sqs_resource_unavailable_queue_url")

          # Use pre-built JDBC URL from Terraform
          DB_URL=$(get_output "os_service_jdbc_url")

          # Mask all sensitive values in logs
          echo "::add-mask::${DB_URL}"
          echo "::add-mask::${IRSA_ROLE_ARN}"
          echo "::add-mask::${SQS_OS_EVENTS}"
          echo "::add-mask::${SQS_QUOTE_APPROVED}"
          echo "::add-mask::${SQS_EXECUTION_COMPLETED}"
          echo "::add-mask::${SQS_PAYMENT_FAILED}"
          echo "::add-mask::${SQS_RESOURCE_UNAVAILABLE}"

          # Export outputs (DB_USERNAME and DB_PASSWORD come from secrets)
          echo "DB_URL=${DB_URL}" >> $GITHUB_OUTPUT
          echo "IRSA_ROLE_ARN=${IRSA_ROLE_ARN}" >> $GITHUB_OUTPUT
          echo "SQS_OS_EVENTS=${SQS_OS_EVENTS}" >> $GITHUB_OUTPUT
          echo "SQS_QUOTE_APPROVED=${SQS_QUOTE_APPROVED}" >> $GITHUB_OUTPUT
          echo "SQS_EXECUTION_COMPLETED=${SQS_EXECUTION_COMPLETED}" >> $GITHUB_OUTPUT
          echo "SQS_PAYMENT_FAILED=${SQS_PAYMENT_FAILED}" >> $GITHUB_OUTPUT
          echo "SQS_RESOURCE_UNAVAILABLE=${SQS_RESOURCE_UNAVAILABLE}" >> $GITHUB_OUTPUT

          echo "Infrastructure outputs parsed successfully!"

      - name: Update kubeconfig for EKS
        run: |
          aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}

      - name: Prepare Kubernetes manifests
        env:
          DB_URL: ${{ steps.parsed-outputs.outputs.DB_URL }}
          DB_USERNAME: ${{ secrets.DB_USERNAME }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          SQS_OS_EVENTS: ${{ steps.parsed-outputs.outputs.SQS_OS_EVENTS }}
          SQS_QUOTE_APPROVED: ${{ steps.parsed-outputs.outputs.SQS_QUOTE_APPROVED }}
          SQS_EXECUTION_COMPLETED: ${{ steps.parsed-outputs.outputs.SQS_EXECUTION_COMPLETED }}
          SQS_PAYMENT_FAILED: ${{ steps.parsed-outputs.outputs.SQS_PAYMENT_FAILED }}
          SQS_RESOURCE_UNAVAILABLE: ${{ steps.parsed-outputs.outputs.SQS_RESOURCE_UNAVAILABLE }}
          IRSA_ROLE_ARN: ${{ steps.parsed-outputs.outputs.IRSA_ROLE_ARN }}
          IMAGE_URI: ${{ needs.build-and-push.outputs.image-uri }}
        run: |
          set -euo pipefail

          # Mask sensitive values
          echo "::add-mask::${DB_URL}"
          echo "::add-mask::${DB_USERNAME}"
          echo "::add-mask::${DB_PASSWORD}"
          echo "::add-mask::${SQS_OS_EVENTS}"
          echo "::add-mask::${SQS_QUOTE_APPROVED}"
          echo "::add-mask::${SQS_EXECUTION_COMPLETED}"
          echo "::add-mask::${SQS_PAYMENT_FAILED}"
          echo "::add-mask::${SQS_RESOURCE_UNAVAILABLE}"
          echo "::add-mask::${IRSA_ROLE_ARN}"

          # Substitute values in secrets.yaml using sed
          sed -i "s|__DB_URL_B64__|$(echo -n "${DB_URL}" | base64 -w0)|g" k8s/secrets.yaml
          sed -i "s|__DB_USERNAME_B64__|$(echo -n "${DB_USERNAME}" | base64 -w0)|g" k8s/secrets.yaml
          sed -i "s|__DB_PASSWORD_B64__|$(echo -n "${DB_PASSWORD}" | base64 -w0)|g" k8s/secrets.yaml
          sed -i "s|__SQS_OS_EVENTS_QUEUE_URL_B64__|$(echo -n "${SQS_OS_EVENTS}" | base64 -w0)|g" k8s/secrets.yaml

          # Substitute values in configmap.yaml
          sed -i "s|__SQS_QUOTE_APPROVED_QUEUE__|${SQS_QUOTE_APPROVED}|g" k8s/configmap.yaml
          sed -i "s|__SQS_EXECUTION_COMPLETED_QUEUE__|${SQS_EXECUTION_COMPLETED}|g" k8s/configmap.yaml
          sed -i "s|__SQS_PAYMENT_FAILED_QUEUE__|${SQS_PAYMENT_FAILED}|g" k8s/configmap.yaml
          sed -i "s|__SQS_RESOURCE_UNAVAILABLE_QUEUE__|${SQS_RESOURCE_UNAVAILABLE}|g" k8s/configmap.yaml

          # Substitute values in service-account.yaml
          sed -i "s|__IRSA_ROLE_ARN__|${IRSA_ROLE_ARN}|g" k8s/service-account.yaml

          # Substitute image in deployment
          sed -i "s|__IMAGE_URI__|${IMAGE_URI}|g" k8s/app-deployment.yaml

          echo "Kubernetes manifests prepared successfully"

      - name: Deploy to Kubernetes
        run: |
          # Apply all resources
          kubectl apply -f k8s/namespace.yaml
          kubectl apply -f k8s/service-account.yaml
          kubectl apply -f k8s/configmap.yaml
          kubectl apply -f k8s/secrets.yaml
          kubectl apply -f k8s/app-deployment.yaml
          kubectl apply -f k8s/app-service.yaml
          kubectl apply -f k8s/hpa.yaml
          
          # Wait for rollout
          kubectl rollout status deployment/os-service -n os-service --timeout=300s

      - name: Verify deployment
        run: |
          kubectl get pods -n os-service
          kubectl get svc -n os-service

      - name: Notify deployment success
        if: success()
        run: echo "Production deployment completed successfully!"

      - name: Rollback on failure
        if: failure()
        run: |
          kubectl rollout undo deployment/os-service -n os-service || true
          echo "Deployment failed, attempted rollback to previous version"
